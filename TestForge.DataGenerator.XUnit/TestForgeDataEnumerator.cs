using System.Collections;

namespace TestForge.DataGenerator.XUnit;

/// <summary>
/// enumerable created by the TestForgeClassDataAttribute as part of the ClassData theory test run
/// </summary>
/// <typeparam name="T"></typeparam>
public class TestForgeDataEnumerator<T> : IEnumerable<object[]>
{

    TestForgeDataEnumeratorConfiguration _configuration;
    int _currentCount = 0;

    public TestForgeDataEnumerator(TestForgeDataEnumeratorConfiguration configuration)
    {
       _configuration = configuration;
    }

    /* things to do:
     *   pass in a GeneratorContext
     *   pass in individual seeds for multiple items
     *   spit out the seed in the output so it can be found
     *   all passing in of seeds for different items
     *   generic generator - have a virtual BuildGenerator
     */

    /// <summary>
    /// returns an enumerator of items generated by the generator returned from GetGenerator
    /// </summary>
    /// <returns></returns>
    public IEnumerator<object[]> GetEnumerator()
    {

        GeneratorContext context = new GeneratorContext(_configuration.PrimarySeed);
        IGenerator<T> generator = GetGenerator(context);

        while (_currentCount < _configuration.Iterations)
        {

            T item = generator.Generate(context);

            yield return new object[] { item };

            _currentCount++;
        }
    }

    /// <summary>
    /// the non-generic IEnumerator GetEnumerator
    /// </summary>
    /// <returns></returns>
    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }

    /// <summary>
    /// retrieves a generator.
    /// </summary>
    /// <param name="context"></param>
    /// <returns></returns>
    /// <exception cref="NotImplementedException"></exception>
    /// <remarks>
    /// this will need to be overridden in any child class.  
    /// </remarks>
    public virtual IGenerator<T> GetGenerator(GeneratorContext context)
    {
        throw new NotImplementedException();
    }

}


