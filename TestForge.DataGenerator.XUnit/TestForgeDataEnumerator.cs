using System.Collections;
using System.Reflection;

namespace TestForge.DataGenerator.XUnit;

/// <summary>
/// enumerable created by the TestForgeClassDataAttribute as part of the ClassData theory test run
/// </summary>
/// <typeparam name="T"></typeparam>
public class TestForgeDataEnumerator : IEnumerable<object[]>
{

    TestForgeDataEnumeratorConfiguration _configuration;
    int _currentCount = 0;

    public TestForgeDataEnumerator(TestForgeDataEnumeratorConfiguration configuration)
    {
        _configuration = configuration;
    }

    /// <summary>
    /// returns an enumerator of items generated by the generator returned from GetGenerator
    /// </summary>
    /// <returns></returns>
    public IEnumerator<object[]> GetEnumerator()
    {

        GeneratorContext context = new GeneratorContext(_configuration.PrimarySeed);

        if (_configuration.ConfigurationTypeEnum == ConfigurationTypeEnum.IterationAndPrimarySeed)
        {
            while (_currentCount < _configuration.Iterations)
            {
                _currentCount++;

                var parameterArray = BuildParameterArray(context.Random.Next(), _currentCount);
                yield return parameterArray;
            }
        }
        else if (_configuration.ConfigurationTypeEnum == ConfigurationTypeEnum.SpecificSeeds)
        {
            foreach(int specificSeed in _configuration.SpecificSeeds)
            {
                _currentCount++;

                var parameterArray = BuildParameterArray(specificSeed, _currentCount);
                yield return parameterArray;
            }
        }
    }

    /// <summary>
    /// the non-generic IEnumerator GetEnumerator
    /// </summary>
    /// <returns></returns>
    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }

    List<ParameterInfo>? paramInfo = null;
    List<GeneratorItem>? generators = null;

    /// <summary>
    /// builds an array of parameters to send to the test
    /// </summary>
    /// <param name="seed"></param>
    /// <param name="iteration"></param>
    /// <returns></returns>
    /// <exception cref="InvalidDataException"></exception>
    private object[] BuildParameterArray(int seed, int iteration)
    {
        List<object> parameterArray = new List<object>();
        paramInfo ??= new List<ParameterInfo>(_configuration.TestMethodInformation.GetParameters());
        generators ??= GetGenerators();


        GeneratorContext context = new GeneratorContext(seed);

        foreach (var param in paramInfo)
        {
            if (generators.FirstOrDefault(x=>x.GeneratorType == param.ParameterType) != null)
            {
                var generator = generators.First(x => x.GeneratorType == param.ParameterType).Generator(context) as IGenerator;

                var dataElement = generator.Generate(context);
                parameterArray.Add(dataElement);
                continue;
            }

            if (generators.FirstOrDefault(x => x.Name == param.Name) != null)
            {
                var generator = generators.First(x => x.Name == param.Name).Generator(context) as IGenerator;

                var dataElement = generator.Generate(context);
                parameterArray.Add(dataElement);
                continue;
            }

            if (param.ParameterType == typeof(GeneratorContext))
            {
                parameterArray.Add(context);
                continue;
            }
            if (param.Name.Equals("seed", StringComparison.InvariantCultureIgnoreCase))
            {
                parameterArray.Add(seed);
                continue;
            }
            if (param.Name.Equals("iteration", StringComparison.InvariantCultureIgnoreCase))
            {
                parameterArray.Add(iteration);
                continue;
            }
            //  if we reach this point, we haven't assigned a parameter.  explode mightily
            throw new InvalidDataException($"Cannot find a generator for parameter: {param.Name}");
        }

        return parameterArray.ToArray();
    }

    /// <summary>
    /// retrieves a set of generators from this or a child class
    /// </summary>
    /// <returns></returns>
    private List<GeneratorItem> GetGenerators()
    {
        List<GeneratorItem> generators = new List<GeneratorItem>();
        var methodList = GetType().GetMethods();
        foreach (var method in methodList)
        {
            var attributes = method.GetCustomAttributes(false);
            var testAttribute = attributes.FirstOrDefault(x => x.GetType() == typeof(GeneratorAttribute)) as GeneratorAttribute;
            if (testAttribute != null)
            {
                generators.Add(new GeneratorItem()
                {
                    Name = testAttribute.Name,
                    GeneratorType = testAttribute.GeneratorType,
                    Generator = x =>
                            {
                                object?[]? xArray = new object?[] { x };
                                var rslt = method.Invoke(this, xArray);
                                return rslt;
                            }
                });
            }
        }

        return generators;
    }


}
    


