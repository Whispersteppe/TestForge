using Microsoft.VisualBasic;
using System.Collections;

namespace TestForge.DataGenerator.XUnit;

/// <summary>
/// enumerable created by the TestForgeClassDataAttribute as part of the ClassData theory test run
/// </summary>
/// <typeparam name="T"></typeparam>
public class TestForgeDataEnumerator<T> : IEnumerable<object[]>
{

    TestForgeDataEnumeratorConfiguration _configuration;
    int _currentCount = 0;

    public TestForgeDataEnumerator(TestForgeDataEnumeratorConfiguration configuration)
    {
        _configuration = configuration;
    }



    /* things to do:
     *   pass in a GeneratorContext
     *   pass in individual seeds for multiple items
     *   spit out the seed in the output so it can be found
     *   all passing in of seeds for different items
     *   generic generator - have a virtual BuildGenerator
     */

    /// <summary>
    /// returns an enumerator of items generated by the generator returned from GetGenerator
    /// </summary>
    /// <returns></returns>
    public IEnumerator<object[]> GetEnumerator()
    {

        GeneratorContext context = new GeneratorContext(_configuration.PrimarySeed);
        //IGenerator<T> generator = GetGenerator(context);

        while (_currentCount < _configuration.Iterations)
        {
            _currentCount++;

            var parameterArray = BuildParameterArray(context.Random.Next(), _currentCount);
            yield return parameterArray;

        }
    }

    private object[] BuildParameterArray(int seed, int iteration)
    {
        List<object> parameterArray = new List<object>();

        GeneratorContext context = new GeneratorContext(seed);

        var paramInfo = _configuration.TestMethodInformation.GetParameters();
        var generators = GetGenerators();

        foreach (var param in paramInfo)
        {
            var foundTypeInDictionary = generators.ContainsKey(param.ParameterType);
            if (foundTypeInDictionary)
            {
                var generator = generators[param.ParameterType](context) as IGenerator;

                var dataElement = generator.Generate(context);
                parameterArray.Add(dataElement);
                continue;
            }
            if (param.ParameterType == typeof(GeneratorContext))
            {
                parameterArray.Add(context);
                continue;
            }
            if (param.Name.Equals("seed", StringComparison.InvariantCultureIgnoreCase))
            {
                parameterArray.Add(seed);
                continue;
            }
            if (param.Name.Equals("iteration", StringComparison.InvariantCultureIgnoreCase))
            {
                parameterArray.Add(iteration);
                continue;
            }

        }

        return parameterArray.ToArray();
    }

    private Dictionary<Type, Func<GeneratorContext, object>> GetGenerators()
    {
        Dictionary<Type, Func<GeneratorContext, object>> generators = new Dictionary<Type, Func<GeneratorContext, object>>();
        var methodList = GetType().GetMethods();
        foreach (var method in methodList)
        {
            var attributes = method.GetCustomAttributes(false);
            var testAttribute = attributes.FirstOrDefault(x => x.GetType() == typeof(GeneratorAttribute)) as GeneratorAttribute;
            if (testAttribute != null)
            {
                generators.Add(testAttribute.GeneratorType, x => 
                            { 
                                object?[]? xArray = new object?[] { x }; 
                                var rslt = method.Invoke(this, xArray); 
                                return rslt; 
                            });
            }
        }

        return generators;
    }

    /// <summary>
    /// the non-generic IEnumerator GetEnumerator
    /// </summary>
    /// <returns></returns>
    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }

    /// <summary>
    /// retrieves a generator.
    /// </summary>
    /// <param name="context"></param>
    /// <returns></returns>
    /// <exception cref="NotImplementedException"></exception>
    /// <remarks>
    /// this will need to be overridden in any child class.  
    /// </remarks>
    //public virtual IGenerator<T> GetGenerator(GeneratorContext context)
    //{
    //    throw new NotImplementedException();
    //}
}

public delegate IGenerator<T> GetGeneratorMethod<T>(GeneratorContext context);

public class GeneratorAttribute : Attribute
{
    public Type GeneratorType { get; set; }

    public GeneratorAttribute(Type generatorType)
    {
        GeneratorType = generatorType;
    }
}
    


